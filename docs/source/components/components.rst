.. _components:

Components
==========

The different py-abac components corresponding to those in the access control architecture are described in this section.
Using these components you can implement fine-grained access control for your protected resources.

.. _components_policy:

Policy
------

This is the component containing rules for accessing resources. A policy object can be created by first defining a
policy JSON using the JSON-based :ref:`policy_language`, and then parsing it using the :class:`Policy` class.

.. code-block:: python

   from py_abac import Policy

   # Policy definition in JSON-based policy language
   policy_json = {
       "uid": "1",
       "description": "Max is not allowed to create, delete, get any resource",
       "effect": "deny",
       "rules": {
           "subject": {"$.name": {"condition": "Equals", "value": "Max"}},
           "resource": {"$.name": {"condition": "RegexMatch", "value": ".*"}},
           "action": [{"$.method": {"condition": "Equals", "value": "create"}},
                      {"$.method": {"condition": "Equals", "value": "delete"}},
                      {"$.method": {"condition": "Equals", "value": "get"}}],
           "context": {}
       },
       "targets": {},
       "priority": 0
   }
   # Prase policy JSON to create Policy object
   policy = Policy.from_json(policy_json)

See the :ref:`policy_language` section for detailed description of JSON structure.


.. _components_access_request:

Access Request
--------------

A :class:`AccessRequest` object represents the access request generated by :ref:`PEP <abac_pep>` in the
:ref:`ABAC architecture <abac_arch>`. All you need to do is take any kind of incoming user request
(REST request, SOAP, etc.) and build an :class:`AccessRequest` object out of it as shown below:

.. code-block:: python

   from py_abac import AccessRequest
   from flask import request, session

   # Create a access request JSON from flask request object
   request_json = {
       "subject": {
           "id": "",
           "attributes": {"name": request.values.get("username")}
       },
       "resource": {
           "id": "",
           "attributes": {"name": request.path}
       },
       "action": {
           "id": "",
           "attributes": {"method": request.method}
       },
       "context": {}
   }
   # Parse JSON and create access request object
   request = AccessRequest.from_json(request_json)


.. note::

   You might have noticed the presence of empty  :code:`"id"` fields for the :code:`subject` , :code:`resource` and
   :code:`action` access control elements in the above example. These are called **target IDs** and are mandatory fields
   for creating an access request object in py-ABAC. The purpose of these fields is explained in detail in the
   :ref:`targets_block` subsection of Policy Language. If you are unsure of their usage, you can safely set them to an
   empty string.

.. note::

   For backward compatibility with py-abac v0.2.0 you can also use the :class:`Request` class to create access request.

.. _components_pdp:

PDP
---

This component is the :ref:`policy decision point <abac_pdp>`, instantiated through the :class:`PDP` class. It is the
main entry point of py-abac for evaluating policies. At a minimum, a :ref:`Storage <components_storage>` object is required to
create a :class:`PDP` object. It has one method, :code:`is_allowed`, which when passed a :class:`AccessRequest`
object, gives you a boolean answer: is access allowed or not?

.. code-block:: python

   from pymongo import MongoClient
   from py_abac import PDP
   from py_abac.storage import MongoStorage

   # Setup storage
   client = MongoClient()
   st = MongoStorage(client)
   # Insert all polices to storage
   for p in policies:
       st.add(p)

   # Create PDP
   pdp = PDP(st)

   # Evaluate if access is allowed
   if pdp.is_allowed(request):
       return "Access Allowed", 200
   else:
       return "Unauthorized Access", 401

By default :class:`PDP`` uses the :class:`DenyOverrides` algorithm for policy evaluation. To specify otherwise, pass the
evaluation algorithm at creation. Moreover, a list of :class:`AttributeProvider` objects can also be provided. See the
sub-section :ref:`components_attribute_provider` for details of their usage.

.. code-block:: python

   from py_abac import PDP, EvaluationAlgorithm
   from py_abac.storage import MongoStorage
   from py_abac.providers import AttributeProvider

   # A simple email attribute provider class
   class EmailAttributeProvider(AttributeProvider):
       def get_attribute_value(self, ace, attribute_path, ctx):
           return "example@gmail.com"

   # Setup storage
   client = MongoClient()
   st = MongoStorage(client)
   # Insert all polices to storage
   for p in policies:
       st.add(p)

   # Create PDP configured to use highest priority algorithm
   # and an additional email attribute provider
   pdp = PDP(st, EvaluationAlgorithm.HIGHEST_PRIORITY, [EmailAttributeProvider()])

The three supported algorithms are :class:`EvaluationAlgorithm.DENY_OVERRIDES`, :class:`EvaluationAlgorithm.ALLOW_OVERRIDES`, and :class:`EvaluationAlgorithm.HIGHEST_PRIORITY`.


.. _components_storage:

Storage
-------

The :class:`Storage` is a component which provides interface for implementing policy persistence. Thus it is a
component used to create :ref:`PAP <abac_pap>`. It provides the following methods:

.. code-block:: python

   # Store a Policy
   add(policy)

   # Retrieve a Policy by its ID
   get(uid)

   # Retrieve all stored Policies (with pagination)
   get_all(limit, offset)

   # Store an updated Policy
   update(policy)

   # Delete Policy from storage by its ID
   delete(uid)

   # Retrieve Policies that match the given target IDs
   get_for_target(subject_id, resource_id, action_id)

Storage may have various backend implementations (RDBMS, NoSQL databases, etc.) and py-ABAC ships with some out of the
box. See below table:

Memory
^^^^^^

Will be part of v0.2.1

MongoDB
^^^^^^^

MongoDB is chosen as the most popular and widespread NO-SQL database.

.. code-block:: python

   from pymongo import MongoClient
   from py_abac.storage import MongoStorage

   client = MongoClient('localhost', 27017)
   storage = MongoStorage(client, 'database-name', collection='optional-collection-name')

Default database and collection names are 'py_abac' and  'py_abac_policies' respectively.

Actions are the same as for any Storage that conforms interface of ``py_abac.storage.base.StorageBase`` base class.

SQL
^^^

Will be part of v0.2.2

Custom Backend
^^^^^^^^^^^^^^

Migrations
^^^^^^^^^^

``py_abac.storage.migration`` is a set of components that are useful for `Storage <#storage>`_. The design and implementation is taken from the `Vakt <https://github.com/kolotaev/vakt>`_ SDK. It's recommended in favor over manual actions on DB schema/data since it's aware of py-ABAC requirements. But it's not mandatory. It is up to a particular Storage to decide whether it needs migrations. It consists of 3 components:


* ``Migration``
* ``MigrationSet``
* ``Migrator``

``Migration`` allows you to describe data modifications between versions. Each storage can have a number of ``Migration`` classes to address different releases with the order of the migration specified in ``order`` property. The class should be located inside corresponding storage module and should implement ``py_abac.storage.migration.Migration``. Migration has 2 main methods (as you might guess) and 1 property:


* ``up`` - runs db "schema" upwards
* ``down`` - runs db "schema" downwards (rolls back the actions of ``up``\ )
* ``order`` - tells the number of the current migration in a row

``MigrationSet`` is a component that represents a collection of Migrations for a Storage. You should define your own migration-set. It should be located inside particular storage module and implement ``py_abac.storage.migration.MigrationSet``. It has 3 methods that lest unimplemented:


* ``migrations`` - should return all initialized Migration objects
* ``save_applied_number`` - saves a number of a lst applied up migration in the Storage for later reference
* ``last_applied`` - returns a number of a lst applied up migration from the Storage

``Migrator`` is an executor of a migrations. It can execute all migrations up or down, or execute a particular migration if ``number`` argument is provided.

Example usage:

.. code-block:: python

   from pymongo import MongoClient
   from py_abac.storage.mongo import MongoStorage, MongoMigrationSet
   from py_abac.storage.migration import Migrator

   client = MongoClient('localhost', 27017)
   storage = MongoStorage(client, 'database-name', collection='optional-collection-name')

   migrator = Migrator(MongoMigrationSet(storage))
   migrator.up()
   ...
   migrator.down()
   ...
   migrator.up(number=2)
   ...
   migrator.down(number=2)


.. _components_attribute_provider:

AttributeProvider
-----------------

:class:`AttributeProvider` is an interface to create a :ref:`PIP <abac_pip>`. The purpose of this object is to provide
attribute values missing in the :class:`AccessRequest` object. During policy evaluation, the :class:`PDP` first checks
the :class:`Request` object for attribute values; If no values are found, it then checks the list of
:class:`AttributeProvider` objects passed during :class:`PDP` creation. In order to create an :class:`AttributeProvider`
object, you need to implement the :code:`get_attribute_value` method:

.. code-block:: python

   from py_abac.provider.base import AttributeProvider

   # A simple email attribute provider class
   class EmailAttributeProvider(AttributeProvider):
       def get_attribute_value(self, ace, attribute_path, ctx):
           """
               Returns a value for an attribute. If value not found
               then return None.


               :param ace: string value indicating the access control
                           element, i.e. "subject", "resource", "action"
                           or "context".
               :param attribute_path: string in ObjectPat notation indicating
                                      the attribute for which the value is
                                      requested.
               :param ctx: evaluation context
           """
           return "example@gmail.com"

As seen in the above example, :code:`get_attribute_value` takes in three arguments: :code:`ace`, :code:`attribute_path`
and :code:`ctx`. The :code:`ace` is a string value indicating for which access control element the attribute value is
being requested. This argument will be set to either :code:`"subject"`, :code:`"resource"`, :code:`"action"`, or
:code:`"context"``. The :code:`attribute_path` argument is a string in  `ObjectPath <http://objectpath.org/>`_ notation
denoting the attribute for which the value is being requested. The :code:`ctx` argument is an `EvaluationContext`_
object. The primary purpose of this argument is to retrieve values of other attributes. A common use-case would be to
return values conditioned upon the values of other attributes.

.. code-block:: python

   # An email attribute provider class
   class EmailAttributeProvider(AttributeProvider):
       def get_attribute_value(self, ace, attribute_path, ctx):
           # Return email for Max
           if ctx.get_attribute_value("subject", "$.name") == "Max":
               return "max@gmail.com"
           # Else return default email
           return "default@gmail.com"

.. warning::

   If the :class:`AttributeProvider` does not contain value for an attribute, the :code:`get_attribute_value` must
   return :code:`None`.

.. _components_evaluation_context:

EvaluationContext
-----------------

An :class:`EvaluationContext` object is created by the :class:`PDP` during policy evaluation. This object is used by
:class:`PDP` for retrieval of those attribute values referred by a policy. It has following properties:

.. code-block:: python

   # The target ID for subject access control element
   ctx.subject_id

   # The target ID for resource access control element
   ctx.resource_id

   # The target ID for action access control element
   ctx.action_id

   # Lookup a value for an attribute of an access control element
   ctx.get_attribute_value(ace: str, attribute_path: str)

During retrieval,  the :class:`EvaluationContext` first checks for an attribute value in the :class:`AccessRequest` object.
If the value is not found, it then checks all the :class:`AttributeProvider` objects sequentially.

.. note::

   As attribute values are retried from :class:`AttributeProvider` objects sequentially, an eager lookup is performed.
   This means any subsequent :class:`AttributeProvider` objects will be skipped moment the very first provider returns
   a value.
